/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type ExitPostExpReturnParamsStruct = {
  netPtFromRemove: BigNumberish;
  netSyFromRemove: BigNumberish;
  netPtRedeem: BigNumberish;
  netSyFromRedeem: BigNumberish;
  totalSyOut: BigNumberish;
};

export type ExitPostExpReturnParamsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  netPtFromRemove: BigNumber;
  netSyFromRemove: BigNumber;
  netPtRedeem: BigNumber;
  netSyFromRedeem: BigNumber;
  totalSyOut: BigNumber;
};

export type ExitPreExpReturnParamsStruct = {
  netPtFromRemove: BigNumberish;
  netSyFromRemove: BigNumberish;
  netPyRedeem: BigNumberish;
  netSyFromRedeem: BigNumberish;
  netPtSwap: BigNumberish;
  netYtSwap: BigNumberish;
  netSyFromSwap: BigNumberish;
  netSyFee: BigNumberish;
  totalSyOut: BigNumberish;
};

export type ExitPreExpReturnParamsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  netPtFromRemove: BigNumber;
  netSyFromRemove: BigNumber;
  netPyRedeem: BigNumber;
  netSyFromRedeem: BigNumber;
  netPtSwap: BigNumber;
  netYtSwap: BigNumber;
  netSyFromSwap: BigNumber;
  netSyFee: BigNumber;
  totalSyOut: BigNumber;
};

export type SwapDataStruct = {
  swapType: BigNumberish;
  extRouter: string;
  extCalldata: BytesLike;
  needScale: boolean;
};

export type SwapDataStructOutput = [number, string, string, boolean] & {
  swapType: number;
  extRouter: string;
  extCalldata: string;
  needScale: boolean;
};

export type TokenInputStruct = {
  tokenIn: string;
  netTokenIn: BigNumberish;
  tokenMintSy: string;
  pendleSwap: string;
  swapData: SwapDataStruct;
};

export type TokenInputStructOutput = [
  string,
  BigNumber,
  string,
  string,
  SwapDataStructOutput
] & {
  tokenIn: string;
  netTokenIn: BigNumber;
  tokenMintSy: string;
  pendleSwap: string;
  swapData: SwapDataStructOutput;
};

export type ApproxParamsStruct = {
  guessMin: BigNumberish;
  guessMax: BigNumberish;
  guessOffchain: BigNumberish;
  maxIteration: BigNumberish;
  eps: BigNumberish;
};

export type ApproxParamsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  guessMin: BigNumber;
  guessMax: BigNumber;
  guessOffchain: BigNumber;
  maxIteration: BigNumber;
  eps: BigNumber;
};

export type OrderStruct = {
  salt: BigNumberish;
  expiry: BigNumberish;
  nonce: BigNumberish;
  orderType: BigNumberish;
  token: string;
  YT: string;
  maker: string;
  receiver: string;
  makingAmount: BigNumberish;
  lnImpliedRate: BigNumberish;
  failSafeRate: BigNumberish;
  permit: BytesLike;
};

export type OrderStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  number,
  string,
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  string
] & {
  salt: BigNumber;
  expiry: BigNumber;
  nonce: BigNumber;
  orderType: number;
  token: string;
  YT: string;
  maker: string;
  receiver: string;
  makingAmount: BigNumber;
  lnImpliedRate: BigNumber;
  failSafeRate: BigNumber;
  permit: string;
};

export type FillOrderParamsStruct = {
  order: OrderStruct;
  signature: BytesLike;
  makingAmount: BigNumberish;
};

export type FillOrderParamsStructOutput = [
  OrderStructOutput,
  string,
  BigNumber
] & { order: OrderStructOutput; signature: string; makingAmount: BigNumber };

export type LimitOrderDataStruct = {
  limitRouter: string;
  epsSkipMarket: BigNumberish;
  normalFills: FillOrderParamsStruct[];
  flashFills: FillOrderParamsStruct[];
  optData: BytesLike;
};

export type LimitOrderDataStructOutput = [
  string,
  BigNumber,
  FillOrderParamsStructOutput[],
  FillOrderParamsStructOutput[],
  string
] & {
  limitRouter: string;
  epsSkipMarket: BigNumber;
  normalFills: FillOrderParamsStructOutput[];
  flashFills: FillOrderParamsStructOutput[];
  optData: string;
};

export type TokenOutputStruct = {
  tokenOut: string;
  minTokenOut: BigNumberish;
  tokenRedeemSy: string;
  pendleSwap: string;
  swapData: SwapDataStruct;
};

export type TokenOutputStructOutput = [
  string,
  BigNumber,
  string,
  string,
  SwapDataStructOutput
] & {
  tokenOut: string;
  minTokenOut: BigNumber;
  tokenRedeemSy: string;
  pendleSwap: string;
  swapData: SwapDataStructOutput;
};

export type RedeemYtIncomeToTokenStructStruct = {
  yt: string;
  doRedeemInterest: boolean;
  doRedeemRewards: boolean;
  tokenRedeemSy: string;
  minTokenRedeemOut: BigNumberish;
};

export type RedeemYtIncomeToTokenStructStructOutput = [
  string,
  boolean,
  boolean,
  string,
  BigNumber
] & {
  yt: string;
  doRedeemInterest: boolean;
  doRedeemRewards: boolean;
  tokenRedeemSy: string;
  minTokenRedeemOut: BigNumber;
};

export type SwapDataExtraStruct = {
  tokenIn: string;
  tokenOut: string;
  minOut: BigNumberish;
  swapData: SwapDataStruct;
};

export type SwapDataExtraStructOutput = [
  string,
  string,
  BigNumber,
  SwapDataStructOutput
] & {
  tokenIn: string;
  tokenOut: string;
  minOut: BigNumber;
  swapData: SwapDataStructOutput;
};

export declare namespace IPActionMiscV3 {
  export type Call3Struct = { allowFailure: boolean; callData: BytesLike };

  export type Call3StructOutput = [boolean, string] & {
    allowFailure: boolean;
    callData: string;
  };

  export type ResultStruct = { success: boolean; returnData: BytesLike };

  export type ResultStructOutput = [boolean, string] & {
    success: boolean;
    returnData: string;
  };
}

export declare namespace IPActionStorageV4 {
  export type SelectorsToFacetStruct = {
    facet: string;
    selectors: BytesLike[];
  };

  export type SelectorsToFacetStructOutput = [string, string[]] & {
    facet: string;
    selectors: string[];
  };
}

export interface IPAllActionV3Interface extends utils.Interface {
  contractName: "IPAllActionV3";
  functions: {
    "addLiquidityDualSyAndPt(address,address,uint256,uint256,uint256)": FunctionFragment;
    "addLiquidityDualTokenAndPt(address,address,(address,uint256,address,address,(uint8,address,bytes,bool)),uint256,uint256)": FunctionFragment;
    "addLiquiditySinglePt(address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "addLiquiditySinglePtSimple(address,address,uint256,uint256)": FunctionFragment;
    "addLiquiditySingleSy(address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "addLiquiditySingleSyKeepYt(address,address,uint256,uint256,uint256)": FunctionFragment;
    "addLiquiditySingleSySimple(address,address,uint256,uint256)": FunctionFragment;
    "addLiquiditySingleToken(address,address,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "addLiquiditySingleTokenKeepYt(address,address,uint256,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "addLiquiditySingleTokenSimple(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "boostMarkets(address[])": FunctionFragment;
    "callAndReflect(address,bytes,bytes,bytes)": FunctionFragment;
    "claimOwnership()": FunctionFragment;
    "exitPostExpToSy(address,address,uint256,uint256,uint256)": FunctionFragment;
    "exitPostExpToToken(address,address,uint256,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "exitPreExpToSy(address,address,uint256,uint256,uint256,uint256,(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "exitPreExpToToken(address,address,uint256,uint256,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "limitRouterCallback(uint256,uint256,uint256,bytes)": FunctionFragment;
    "mintPyFromSy(address,address,uint256,uint256)": FunctionFragment;
    "mintPyFromToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "mintSyFromToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "multicall((bool,bytes)[])": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingOwner()": FunctionFragment;
    "redeemDueInterestAndRewards(address,address[],address[],address[])": FunctionFragment;
    "redeemDueInterestAndRewardsV2(address[],(address,bool,bool,address,uint256)[],address[],address,(address,address,uint256,(uint8,address,bytes,bool))[])": FunctionFragment;
    "redeemPyToSy(address,address,uint256,uint256)": FunctionFragment;
    "redeemPyToToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "redeemSyToToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "removeLiquidityDualSyAndPt(address,address,uint256,uint256,uint256)": FunctionFragment;
    "removeLiquidityDualTokenAndPt(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)),uint256)": FunctionFragment;
    "removeLiquiditySinglePt(address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "removeLiquiditySinglePtSimple(address,address,uint256,uint256)": FunctionFragment;
    "removeLiquiditySingleSy(address,address,uint256,uint256,(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "removeLiquiditySingleToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "selectorToFacet(bytes4)": FunctionFragment;
    "setSelectorToFacets((address,bytes4[])[])": FunctionFragment;
    "simulate(address,bytes)": FunctionFragment;
    "swapCallback(int256,int256,bytes)": FunctionFragment;
    "swapExactPtForSy(address,address,uint256,uint256,(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactPtForToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactSyForPt(address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactSyForPtSimple(address,address,uint256,uint256)": FunctionFragment;
    "swapExactSyForYt(address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactSyForYtSimple(address,address,uint256,uint256)": FunctionFragment;
    "swapExactTokenForPt(address,address,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactTokenForPtSimple(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "swapExactTokenForYt(address,address,uint256,(uint256,uint256,uint256,uint256,uint256),(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactTokenForYtSimple(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)))": FunctionFragment;
    "swapExactYtForSy(address,address,uint256,uint256,(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapExactYtForToken(address,address,uint256,(address,uint256,address,address,(uint8,address,bytes,bool)),(address,uint256,((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],((uint256,uint256,uint256,uint8,address,address,address,address,uint256,uint256,uint256,bytes),bytes,uint256)[],bytes))": FunctionFragment;
    "swapTokenToTokenViaSy(address,address,(address,uint256,address,address,(uint8,address,bytes,bool)),address,uint256)": FunctionFragment;
    "swapTokensToTokens(address,(address,address,uint256,(uint8,address,bytes,bool))[],uint256[])": FunctionFragment;
    "transferOwnership(address,bool,bool)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addLiquidityDualSyAndPt",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquidityDualTokenAndPt",
    values: [string, string, TokenInputStruct, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySinglePt",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      ApproxParamsStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySinglePtSimple",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleSy",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      ApproxParamsStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleSyKeepYt",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleSySimple",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleToken",
    values: [
      string,
      string,
      BigNumberish,
      ApproxParamsStruct,
      TokenInputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleTokenKeepYt",
    values: [string, string, BigNumberish, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquiditySingleTokenSimple",
    values: [string, string, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "boostMarkets",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "callAndReflect",
    values: [string, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "claimOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "exitPostExpToSy",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "exitPostExpToToken",
    values: [string, string, BigNumberish, BigNumberish, TokenOutputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "exitPreExpToSy",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "exitPreExpToToken",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      TokenOutputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "limitRouterCallback",
    values: [BigNumberish, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mintPyFromSy",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintPyFromToken",
    values: [string, string, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "mintSyFromToken",
    values: [string, string, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [IPActionMiscV3.Call3Struct[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "redeemDueInterestAndRewards",
    values: [string, string[], string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemDueInterestAndRewardsV2",
    values: [
      string[],
      RedeemYtIncomeToTokenStructStruct[],
      string[],
      string,
      SwapDataExtraStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemPyToSy",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemPyToToken",
    values: [string, string, BigNumberish, TokenOutputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemSyToToken",
    values: [string, string, BigNumberish, TokenOutputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidityDualSyAndPt",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidityDualTokenAndPt",
    values: [string, string, BigNumberish, TokenOutputStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquiditySinglePt",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      ApproxParamsStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquiditySinglePtSimple",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquiditySingleSy",
    values: [string, string, BigNumberish, BigNumberish, LimitOrderDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquiditySingleToken",
    values: [
      string,
      string,
      BigNumberish,
      TokenOutputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "selectorToFacet",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setSelectorToFacets",
    values: [IPActionStorageV4.SelectorsToFacetStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "simulate",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swapCallback",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactPtForSy",
    values: [string, string, BigNumberish, BigNumberish, LimitOrderDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactPtForToken",
    values: [
      string,
      string,
      BigNumberish,
      TokenOutputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactSyForPt",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      ApproxParamsStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactSyForPtSimple",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactSyForYt",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      ApproxParamsStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactSyForYtSimple",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactTokenForPt",
    values: [
      string,
      string,
      BigNumberish,
      ApproxParamsStruct,
      TokenInputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactTokenForPtSimple",
    values: [string, string, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactTokenForYt",
    values: [
      string,
      string,
      BigNumberish,
      ApproxParamsStruct,
      TokenInputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactTokenForYtSimple",
    values: [string, string, BigNumberish, TokenInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactYtForSy",
    values: [string, string, BigNumberish, BigNumberish, LimitOrderDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactYtForToken",
    values: [
      string,
      string,
      BigNumberish,
      TokenOutputStruct,
      LimitOrderDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokenToTokenViaSy",
    values: [string, string, TokenInputStruct, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokensToTokens",
    values: [string, SwapDataExtraStruct[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string, boolean, boolean]
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidityDualSyAndPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquidityDualTokenAndPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySinglePt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySinglePtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleSyKeepYt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleSySimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleTokenKeepYt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquiditySingleTokenSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "boostMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAndReflect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitPostExpToSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitPostExpToToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitPreExpToSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitPreExpToToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "limitRouterCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintPyFromSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintPyFromToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintSyFromToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemDueInterestAndRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemDueInterestAndRewardsV2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemPyToSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemPyToToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemSyToToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidityDualSyAndPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidityDualTokenAndPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquiditySinglePt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquiditySinglePtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquiditySingleSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquiditySingleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "selectorToFacet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSelectorToFacets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "simulate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactPtForSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactPtForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactSyForPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactSyForPtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactSyForYt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactSyForYtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactTokenForPt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactTokenForPtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactTokenForYt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactTokenForYtSimple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactYtForSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactYtForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokenToTokenViaSy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokensToTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;

  events: {
    "AddLiquidityDualSyAndPt(address,address,address,uint256,uint256,uint256)": EventFragment;
    "AddLiquidityDualTokenAndPt(address,address,address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "AddLiquiditySinglePt(address,address,address,uint256,uint256)": EventFragment;
    "AddLiquiditySingleSy(address,address,address,uint256,uint256)": EventFragment;
    "AddLiquiditySingleSyKeepYt(address,address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "AddLiquiditySingleToken(address,address,address,address,uint256,uint256,uint256)": EventFragment;
    "AddLiquiditySingleTokenKeepYt(address,address,address,address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "ExitPostExpToSy(address,address,address,uint256,tuple)": EventFragment;
    "ExitPostExpToToken(address,address,address,address,uint256,uint256,tuple)": EventFragment;
    "ExitPreExpToSy(address,address,address,uint256,tuple)": EventFragment;
    "ExitPreExpToToken(address,address,address,address,uint256,uint256,tuple)": EventFragment;
    "MintPyFromSy(address,address,address,uint256,uint256)": EventFragment;
    "MintPyFromToken(address,address,address,address,uint256,uint256,uint256)": EventFragment;
    "MintSyFromToken(address,address,address,address,uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RedeemPyToSy(address,address,address,uint256,uint256)": EventFragment;
    "RedeemPyToToken(address,address,address,address,uint256,uint256,uint256)": EventFragment;
    "RedeemSyToToken(address,address,address,address,uint256,uint256)": EventFragment;
    "RemoveLiquidityDualSyAndPt(address,address,address,uint256,uint256,uint256)": EventFragment;
    "RemoveLiquidityDualTokenAndPt(address,address,address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "RemoveLiquiditySinglePt(address,address,address,uint256,uint256)": EventFragment;
    "RemoveLiquiditySingleSy(address,address,address,uint256,uint256)": EventFragment;
    "RemoveLiquiditySingleToken(address,address,address,address,uint256,uint256,uint256)": EventFragment;
    "SelectorToFacetSet(bytes4,address)": EventFragment;
    "SwapPtAndSy(address,address,address,int256,int256)": EventFragment;
    "SwapPtAndToken(address,address,address,address,int256,int256,uint256)": EventFragment;
    "SwapYtAndSy(address,address,address,int256,int256)": EventFragment;
    "SwapYtAndToken(address,address,address,address,int256,int256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddLiquidityDualSyAndPt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddLiquidityDualTokenAndPt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddLiquiditySinglePt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddLiquiditySingleSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddLiquiditySingleSyKeepYt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddLiquiditySingleToken"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AddLiquiditySingleTokenKeepYt"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExitPostExpToSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExitPostExpToToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExitPreExpToSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExitPreExpToToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintPyFromSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintPyFromToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintSyFromToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemPyToSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemPyToToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemSyToToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveLiquidityDualSyAndPt"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "RemoveLiquidityDualTokenAndPt"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveLiquiditySinglePt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveLiquiditySingleSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveLiquiditySingleToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SelectorToFacetSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapPtAndSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapPtAndToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapYtAndSy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapYtAndToken"): EventFragment;
}

export type AddLiquidityDualSyAndPtEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netSyUsed: BigNumber;
    netPtUsed: BigNumber;
    netLpOut: BigNumber;
  }
>;

export type AddLiquidityDualSyAndPtEventFilter =
  TypedEventFilter<AddLiquidityDualSyAndPtEvent>;

export type AddLiquidityDualTokenAndPtEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    tokenIn: string;
    receiver: string;
    netTokenUsed: BigNumber;
    netPtUsed: BigNumber;
    netLpOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type AddLiquidityDualTokenAndPtEventFilter =
  TypedEventFilter<AddLiquidityDualTokenAndPtEvent>;

export type AddLiquiditySinglePtEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netPtIn: BigNumber;
    netLpOut: BigNumber;
  }
>;

export type AddLiquiditySinglePtEventFilter =
  TypedEventFilter<AddLiquiditySinglePtEvent>;

export type AddLiquiditySingleSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netSyIn: BigNumber;
    netLpOut: BigNumber;
  }
>;

export type AddLiquiditySingleSyEventFilter =
  TypedEventFilter<AddLiquiditySingleSyEvent>;

export type AddLiquiditySingleSyKeepYtEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netSyIn: BigNumber;
    netSyMintPy: BigNumber;
    netLpOut: BigNumber;
    netYtOut: BigNumber;
  }
>;

export type AddLiquiditySingleSyKeepYtEventFilter =
  TypedEventFilter<AddLiquiditySingleSyKeepYtEvent>;

export type AddLiquiditySingleTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netTokenIn: BigNumber;
    netLpOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type AddLiquiditySingleTokenEventFilter =
  TypedEventFilter<AddLiquiditySingleTokenEvent>;

export type AddLiquiditySingleTokenKeepYtEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netTokenIn: BigNumber;
    netLpOut: BigNumber;
    netYtOut: BigNumber;
    netSyMintPy: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type AddLiquiditySingleTokenKeepYtEventFilter =
  TypedEventFilter<AddLiquiditySingleTokenKeepYtEvent>;

export type ExitPostExpToSyEvent = TypedEvent<
  [string, string, string, BigNumber, ExitPostExpReturnParamsStructOutput],
  {
    caller: string;
    market: string;
    receiver: string;
    netLpIn: BigNumber;
    params: ExitPostExpReturnParamsStructOutput;
  }
>;

export type ExitPostExpToSyEventFilter = TypedEventFilter<ExitPostExpToSyEvent>;

export type ExitPostExpToTokenEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    ExitPostExpReturnParamsStructOutput
  ],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netLpIn: BigNumber;
    totalTokenOut: BigNumber;
    params: ExitPostExpReturnParamsStructOutput;
  }
>;

export type ExitPostExpToTokenEventFilter =
  TypedEventFilter<ExitPostExpToTokenEvent>;

export type ExitPreExpToSyEvent = TypedEvent<
  [string, string, string, BigNumber, ExitPreExpReturnParamsStructOutput],
  {
    caller: string;
    market: string;
    receiver: string;
    netLpIn: BigNumber;
    params: ExitPreExpReturnParamsStructOutput;
  }
>;

export type ExitPreExpToSyEventFilter = TypedEventFilter<ExitPreExpToSyEvent>;

export type ExitPreExpToTokenEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    ExitPreExpReturnParamsStructOutput
  ],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netLpIn: BigNumber;
    totalTokenOut: BigNumber;
    params: ExitPreExpReturnParamsStructOutput;
  }
>;

export type ExitPreExpToTokenEventFilter =
  TypedEventFilter<ExitPreExpToTokenEvent>;

export type MintPyFromSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    receiver: string;
    YT: string;
    netSyIn: BigNumber;
    netPyOut: BigNumber;
  }
>;

export type MintPyFromSyEventFilter = TypedEventFilter<MintPyFromSyEvent>;

export type MintPyFromTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    tokenIn: string;
    YT: string;
    receiver: string;
    netTokenIn: BigNumber;
    netPyOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type MintPyFromTokenEventFilter = TypedEventFilter<MintPyFromTokenEvent>;

export type MintSyFromTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    tokenIn: string;
    SY: string;
    receiver: string;
    netTokenIn: BigNumber;
    netSyOut: BigNumber;
  }
>;

export type MintSyFromTokenEventFilter = TypedEventFilter<MintSyFromTokenEvent>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  { previousOwner: string; newOwner: string }
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export type RedeemPyToSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    receiver: string;
    YT: string;
    netPyIn: BigNumber;
    netSyOut: BigNumber;
  }
>;

export type RedeemPyToSyEventFilter = TypedEventFilter<RedeemPyToSyEvent>;

export type RedeemPyToTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    tokenOut: string;
    YT: string;
    receiver: string;
    netPyIn: BigNumber;
    netTokenOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type RedeemPyToTokenEventFilter = TypedEventFilter<RedeemPyToTokenEvent>;

export type RedeemSyToTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    tokenOut: string;
    SY: string;
    receiver: string;
    netSyIn: BigNumber;
    netTokenOut: BigNumber;
  }
>;

export type RedeemSyToTokenEventFilter = TypedEventFilter<RedeemSyToTokenEvent>;

export type RemoveLiquidityDualSyAndPtEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netLpToRemove: BigNumber;
    netPtOut: BigNumber;
    netSyOut: BigNumber;
  }
>;

export type RemoveLiquidityDualSyAndPtEventFilter =
  TypedEventFilter<RemoveLiquidityDualSyAndPtEvent>;

export type RemoveLiquidityDualTokenAndPtEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    tokenOut: string;
    receiver: string;
    netLpToRemove: BigNumber;
    netPtOut: BigNumber;
    netTokenOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type RemoveLiquidityDualTokenAndPtEventFilter =
  TypedEventFilter<RemoveLiquidityDualTokenAndPtEvent>;

export type RemoveLiquiditySinglePtEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netLpToRemove: BigNumber;
    netPtOut: BigNumber;
  }
>;

export type RemoveLiquiditySinglePtEventFilter =
  TypedEventFilter<RemoveLiquiditySinglePtEvent>;

export type RemoveLiquiditySingleSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netLpToRemove: BigNumber;
    netSyOut: BigNumber;
  }
>;

export type RemoveLiquiditySingleSyEventFilter =
  TypedEventFilter<RemoveLiquiditySingleSyEvent>;

export type RemoveLiquiditySingleTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netLpToRemove: BigNumber;
    netTokenOut: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type RemoveLiquiditySingleTokenEventFilter =
  TypedEventFilter<RemoveLiquiditySingleTokenEvent>;

export type SelectorToFacetSetEvent = TypedEvent<
  [string, string],
  { selector: string; facet: string }
>;

export type SelectorToFacetSetEventFilter =
  TypedEventFilter<SelectorToFacetSetEvent>;

export type SwapPtAndSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netPtToAccount: BigNumber;
    netSyToAccount: BigNumber;
  }
>;

export type SwapPtAndSyEventFilter = TypedEventFilter<SwapPtAndSyEvent>;

export type SwapPtAndTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netPtToAccount: BigNumber;
    netTokenToAccount: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type SwapPtAndTokenEventFilter = TypedEventFilter<SwapPtAndTokenEvent>;

export type SwapYtAndSyEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    receiver: string;
    netYtToAccount: BigNumber;
    netSyToAccount: BigNumber;
  }
>;

export type SwapYtAndSyEventFilter = TypedEventFilter<SwapYtAndSyEvent>;

export type SwapYtAndTokenEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  {
    caller: string;
    market: string;
    token: string;
    receiver: string;
    netYtToAccount: BigNumber;
    netTokenToAccount: BigNumber;
    netSyInterm: BigNumber;
  }
>;

export type SwapYtAndTokenEventFilter = TypedEventFilter<SwapYtAndTokenEvent>;

export interface IPAllActionV3 extends BaseContract {
  contractName: "IPAllActionV3";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IPAllActionV3Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netSyDesired: BigNumberish,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      input: TokenInputStruct,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySinglePt(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtSwapToSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleSy(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleSyKeepYt(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleSySimple(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleToken(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleTokenKeepYt(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquiditySingleTokenSimple(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    boostMarkets(
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    callAndReflect(
      reflector: string,
      selfCall1: BytesLike,
      selfCall2: BytesLike,
      reflectCall: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    exitPostExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    exitPostExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    exitPreExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    exitPreExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    limitRouterCallback(
      actualMaking: BigNumberish,
      actualTaking: BigNumberish,
      totalFee: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    mintPyFromSy(
      receiver: string,
      YT: string,
      netSyIn: BigNumberish,
      minPyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    mintPyFromToken(
      receiver: string,
      YT: string,
      minPyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    mintSyFromToken(
      receiver: string,
      SY: string,
      minSyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    multicall(
      calls: IPActionMiscV3.Call3Struct[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    redeemDueInterestAndRewards(
      user: string,
      sys: string[],
      yts: string[],
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemDueInterestAndRewardsV2(
      SYs: string[],
      YTs: RedeemYtIncomeToTokenStructStruct[],
      markets: string[],
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemPyToSy(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemPyToToken(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemSyToToken(
      receiver: string,
      SY: string,
      netSyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquiditySinglePt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquiditySingleSy(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquiditySingleToken(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    selectorToFacet(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    setSelectorToFacets(
      arr: IPActionStorageV4.SelectorsToFacetStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    simulate(
      target: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapCallback(
      ptToAccount: BigNumberish,
      syToAccount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactPtForSy(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactPtForToken(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactSyForPt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactSyForPtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactSyForYt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactSyForYtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactTokenForPt(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactTokenForPtSimple(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactTokenForYt(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactTokenForYtSimple(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactYtForSy(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactYtForToken(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapTokenToTokenViaSy(
      receiver: string,
      SY: string,
      input: TokenInputStruct,
      tokenRedeemSy: string,
      minTokenOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapTokensToTokens(
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      netSwaps: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  addLiquidityDualSyAndPt(
    receiver: string,
    market: string,
    netSyDesired: BigNumberish,
    netPtDesired: BigNumberish,
    minLpOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquidityDualTokenAndPt(
    receiver: string,
    market: string,
    input: TokenInputStruct,
    netPtDesired: BigNumberish,
    minLpOut: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySinglePt(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    minLpOut: BigNumberish,
    guessPtSwapToSy: ApproxParamsStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySinglePtSimple(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    minLpOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleSy(
    receiver: string,
    market: string,
    netSyIn: BigNumberish,
    minLpOut: BigNumberish,
    guessPtReceivedFromSy: ApproxParamsStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleSyKeepYt(
    receiver: string,
    market: string,
    netSyIn: BigNumberish,
    minLpOut: BigNumberish,
    minYtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleSySimple(
    receiver: string,
    market: string,
    netSyIn: BigNumberish,
    minLpOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleToken(
    receiver: string,
    market: string,
    minLpOut: BigNumberish,
    guessPtReceivedFromSy: ApproxParamsStruct,
    input: TokenInputStruct,
    limit: LimitOrderDataStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleTokenKeepYt(
    receiver: string,
    market: string,
    minLpOut: BigNumberish,
    minYtOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquiditySingleTokenSimple(
    receiver: string,
    market: string,
    minLpOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  boostMarkets(
    markets: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callAndReflect(
    reflector: string,
    selfCall1: BytesLike,
    selfCall2: BytesLike,
    reflectCall: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  exitPostExpToSy(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    netLpIn: BigNumberish,
    minSyOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  exitPostExpToToken(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    netLpIn: BigNumberish,
    output: TokenOutputStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  exitPreExpToSy(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    netYtIn: BigNumberish,
    netLpIn: BigNumberish,
    minSyOut: BigNumberish,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  exitPreExpToToken(
    receiver: string,
    market: string,
    netPtIn: BigNumberish,
    netYtIn: BigNumberish,
    netLpIn: BigNumberish,
    output: TokenOutputStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  limitRouterCallback(
    actualMaking: BigNumberish,
    actualTaking: BigNumberish,
    totalFee: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  mintPyFromSy(
    receiver: string,
    YT: string,
    netSyIn: BigNumberish,
    minPyOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  mintPyFromToken(
    receiver: string,
    YT: string,
    minPyOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  mintSyFromToken(
    receiver: string,
    SY: string,
    minSyOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  multicall(
    calls: IPActionMiscV3.Call3Struct[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  redeemDueInterestAndRewards(
    user: string,
    sys: string[],
    yts: string[],
    markets: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemDueInterestAndRewardsV2(
    SYs: string[],
    YTs: RedeemYtIncomeToTokenStructStruct[],
    markets: string[],
    pendleSwap: string,
    swaps: SwapDataExtraStruct[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemPyToSy(
    receiver: string,
    YT: string,
    netPyIn: BigNumberish,
    minSyOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemPyToToken(
    receiver: string,
    YT: string,
    netPyIn: BigNumberish,
    output: TokenOutputStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemSyToToken(
    receiver: string,
    SY: string,
    netSyIn: BigNumberish,
    output: TokenOutputStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquidityDualSyAndPt(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    minSyOut: BigNumberish,
    minPtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquidityDualTokenAndPt(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    output: TokenOutputStruct,
    minPtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquiditySinglePt(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    minPtOut: BigNumberish,
    guessPtReceivedFromSy: ApproxParamsStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquiditySinglePtSimple(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    minPtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquiditySingleSy(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    minSyOut: BigNumberish,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquiditySingleToken(
    receiver: string,
    market: string,
    netLpToRemove: BigNumberish,
    output: TokenOutputStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  selectorToFacet(
    selector: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  setSelectorToFacets(
    arr: IPActionStorageV4.SelectorsToFacetStruct[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  simulate(
    target: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapCallback(
    ptToAccount: BigNumberish,
    syToAccount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactPtForSy(
    receiver: string,
    market: string,
    exactPtIn: BigNumberish,
    minSyOut: BigNumberish,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactPtForToken(
    receiver: string,
    market: string,
    exactPtIn: BigNumberish,
    output: TokenOutputStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactSyForPt(
    receiver: string,
    market: string,
    exactSyIn: BigNumberish,
    minPtOut: BigNumberish,
    guessPtOut: ApproxParamsStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactSyForPtSimple(
    receiver: string,
    market: string,
    exactSyIn: BigNumberish,
    minPtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactSyForYt(
    receiver: string,
    market: string,
    exactSyIn: BigNumberish,
    minYtOut: BigNumberish,
    guessYtOut: ApproxParamsStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactSyForYtSimple(
    receiver: string,
    market: string,
    exactSyIn: BigNumberish,
    minYtOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactTokenForPt(
    receiver: string,
    market: string,
    minPtOut: BigNumberish,
    guessPtOut: ApproxParamsStruct,
    input: TokenInputStruct,
    limit: LimitOrderDataStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactTokenForPtSimple(
    receiver: string,
    market: string,
    minPtOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactTokenForYt(
    receiver: string,
    market: string,
    minYtOut: BigNumberish,
    guessYtOut: ApproxParamsStruct,
    input: TokenInputStruct,
    limit: LimitOrderDataStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactTokenForYtSimple(
    receiver: string,
    market: string,
    minYtOut: BigNumberish,
    input: TokenInputStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactYtForSy(
    receiver: string,
    market: string,
    exactYtIn: BigNumberish,
    minSyOut: BigNumberish,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactYtForToken(
    receiver: string,
    market: string,
    exactYtIn: BigNumberish,
    output: TokenOutputStruct,
    limit: LimitOrderDataStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapTokenToTokenViaSy(
    receiver: string,
    SY: string,
    input: TokenInputStruct,
    tokenRedeemSy: string,
    minTokenOut: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapTokensToTokens(
    pendleSwap: string,
    swaps: SwapDataExtraStruct[],
    netSwaps: BigNumberish[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    direct: boolean,
    renounce: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netSyDesired: BigNumberish,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netSyUsed: BigNumber;
        netPtUsed: BigNumber;
      }
    >;

    addLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      input: TokenInputStruct,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netPtUsed: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    addLiquiditySinglePt(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtSwapToSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netLpOut: BigNumber; netSyFee: BigNumber }
    >;

    addLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netLpOut: BigNumber; netSyFee: BigNumber }
    >;

    addLiquiditySingleSy(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netLpOut: BigNumber; netSyFee: BigNumber }
    >;

    addLiquiditySingleSyKeepYt(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netYtOut: BigNumber;
        netSyMintPy: BigNumber;
      }
    >;

    addLiquiditySingleSySimple(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netLpOut: BigNumber; netSyFee: BigNumber }
    >;

    addLiquiditySingleToken(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    addLiquiditySingleTokenKeepYt(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netYtOut: BigNumber;
        netSyMintPy: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    addLiquiditySingleTokenSimple(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netLpOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    boostMarkets(markets: string[], overrides?: CallOverrides): Promise<void>;

    callAndReflect(
      reflector: string,
      selfCall1: BytesLike,
      selfCall2: BytesLike,
      reflectCall: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        selfRes1: string;
        selfRes2: string;
        reflectRes: string;
      }
    >;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    exitPostExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ExitPostExpReturnParamsStructOutput>;

    exitPostExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, ExitPostExpReturnParamsStructOutput] & {
        netTokenOut: BigNumber;
        params: ExitPostExpReturnParamsStructOutput;
      }
    >;

    exitPreExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<ExitPreExpReturnParamsStructOutput>;

    exitPreExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, ExitPreExpReturnParamsStructOutput] & {
        netTokenOut: BigNumber;
        params: ExitPreExpReturnParamsStructOutput;
      }
    >;

    limitRouterCallback(
      actualMaking: BigNumberish,
      actualTaking: BigNumberish,
      totalFee: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    mintPyFromSy(
      receiver: string,
      YT: string,
      netSyIn: BigNumberish,
      minPyOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintPyFromToken(
      receiver: string,
      YT: string,
      minPyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netPyOut: BigNumber; netSyInterm: BigNumber }
    >;

    mintSyFromToken(
      receiver: string,
      SY: string,
      minSyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(
      calls: IPActionMiscV3.Call3Struct[],
      overrides?: CallOverrides
    ): Promise<IPActionMiscV3.ResultStructOutput[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    redeemDueInterestAndRewards(
      user: string,
      sys: string[],
      yts: string[],
      markets: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    redeemDueInterestAndRewardsV2(
      SYs: string[],
      YTs: RedeemYtIncomeToTokenStructStruct[],
      markets: string[],
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        netOutFromSwaps: BigNumber[];
        netInterests: BigNumber[];
      }
    >;

    redeemPyToSy(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemPyToToken(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    redeemSyToToken(
      receiver: string,
      SY: string,
      netSyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netSyOut: BigNumber; netPtOut: BigNumber }
    >;

    removeLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      minPtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netPtOut: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    removeLiquiditySinglePt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netPtOut: BigNumber; netSyFee: BigNumber }
    >;

    removeLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netPtOut: BigNumber; netSyFee: BigNumber }
    >;

    removeLiquiditySingleSy(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netSyOut: BigNumber; netSyFee: BigNumber }
    >;

    removeLiquiditySingleToken(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    selectorToFacet(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    setSelectorToFacets(
      arr: IPActionStorageV4.SelectorsToFacetStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    simulate(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    swapCallback(
      ptToAccount: BigNumberish,
      syToAccount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    swapExactPtForSy(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netSyOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactPtForToken(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapExactSyForPt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netPtOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactSyForPtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netPtOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactSyForYt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netYtOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactSyForYtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netYtOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactTokenForPt(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netPtOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapExactTokenForPtSimple(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netPtOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapExactTokenForYt(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netYtOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapExactTokenForYtSimple(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netYtOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapExactYtForSy(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { netSyOut: BigNumber; netSyFee: BigNumber }
    >;

    swapExactYtForToken(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netSyFee: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapTokenToTokenViaSy(
      receiver: string,
      SY: string,
      input: TokenInputStruct,
      tokenRedeemSy: string,
      minTokenOut: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        netTokenOut: BigNumber;
        netSyInterm: BigNumber;
      }
    >;

    swapTokensToTokens(
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      netSwaps: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AddLiquidityDualSyAndPt(address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyUsed?: null,
      netPtUsed?: null,
      netLpOut?: null
    ): AddLiquidityDualSyAndPtEventFilter;
    AddLiquidityDualSyAndPt(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyUsed?: null,
      netPtUsed?: null,
      netLpOut?: null
    ): AddLiquidityDualSyAndPtEventFilter;

    "AddLiquidityDualTokenAndPt(address,address,address,address,uint256,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      tokenIn?: string | null,
      receiver?: null,
      netTokenUsed?: null,
      netPtUsed?: null,
      netLpOut?: null,
      netSyInterm?: null
    ): AddLiquidityDualTokenAndPtEventFilter;
    AddLiquidityDualTokenAndPt(
      caller?: string | null,
      market?: string | null,
      tokenIn?: string | null,
      receiver?: null,
      netTokenUsed?: null,
      netPtUsed?: null,
      netLpOut?: null,
      netSyInterm?: null
    ): AddLiquidityDualTokenAndPtEventFilter;

    "AddLiquiditySinglePt(address,address,address,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netPtIn?: null,
      netLpOut?: null
    ): AddLiquiditySinglePtEventFilter;
    AddLiquiditySinglePt(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netPtIn?: null,
      netLpOut?: null
    ): AddLiquiditySinglePtEventFilter;

    "AddLiquiditySingleSy(address,address,address,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyIn?: null,
      netLpOut?: null
    ): AddLiquiditySingleSyEventFilter;
    AddLiquiditySingleSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyIn?: null,
      netLpOut?: null
    ): AddLiquiditySingleSyEventFilter;

    "AddLiquiditySingleSyKeepYt(address,address,address,uint256,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyIn?: null,
      netSyMintPy?: null,
      netLpOut?: null,
      netYtOut?: null
    ): AddLiquiditySingleSyKeepYtEventFilter;
    AddLiquiditySingleSyKeepYt(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netSyIn?: null,
      netSyMintPy?: null,
      netLpOut?: null,
      netYtOut?: null
    ): AddLiquiditySingleSyKeepYtEventFilter;

    "AddLiquiditySingleToken(address,address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netLpOut?: null,
      netSyInterm?: null
    ): AddLiquiditySingleTokenEventFilter;
    AddLiquiditySingleToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netLpOut?: null,
      netSyInterm?: null
    ): AddLiquiditySingleTokenEventFilter;

    "AddLiquiditySingleTokenKeepYt(address,address,address,address,uint256,uint256,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netLpOut?: null,
      netYtOut?: null,
      netSyMintPy?: null,
      netSyInterm?: null
    ): AddLiquiditySingleTokenKeepYtEventFilter;
    AddLiquiditySingleTokenKeepYt(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netLpOut?: null,
      netYtOut?: null,
      netSyMintPy?: null,
      netSyInterm?: null
    ): AddLiquiditySingleTokenKeepYtEventFilter;

    "ExitPostExpToSy(address,address,address,uint256,tuple)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpIn?: null,
      params?: null
    ): ExitPostExpToSyEventFilter;
    ExitPostExpToSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpIn?: null,
      params?: null
    ): ExitPostExpToSyEventFilter;

    "ExitPostExpToToken(address,address,address,address,uint256,uint256,tuple)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpIn?: null,
      totalTokenOut?: null,
      params?: null
    ): ExitPostExpToTokenEventFilter;
    ExitPostExpToToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpIn?: null,
      totalTokenOut?: null,
      params?: null
    ): ExitPostExpToTokenEventFilter;

    "ExitPreExpToSy(address,address,address,uint256,tuple)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpIn?: null,
      params?: null
    ): ExitPreExpToSyEventFilter;
    ExitPreExpToSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpIn?: null,
      params?: null
    ): ExitPreExpToSyEventFilter;

    "ExitPreExpToToken(address,address,address,address,uint256,uint256,tuple)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpIn?: null,
      totalTokenOut?: null,
      params?: null
    ): ExitPreExpToTokenEventFilter;
    ExitPreExpToToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpIn?: null,
      totalTokenOut?: null,
      params?: null
    ): ExitPreExpToTokenEventFilter;

    "MintPyFromSy(address,address,address,uint256,uint256)"(
      caller?: string | null,
      receiver?: string | null,
      YT?: string | null,
      netSyIn?: null,
      netPyOut?: null
    ): MintPyFromSyEventFilter;
    MintPyFromSy(
      caller?: string | null,
      receiver?: string | null,
      YT?: string | null,
      netSyIn?: null,
      netPyOut?: null
    ): MintPyFromSyEventFilter;

    "MintPyFromToken(address,address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      tokenIn?: string | null,
      YT?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netPyOut?: null,
      netSyInterm?: null
    ): MintPyFromTokenEventFilter;
    MintPyFromToken(
      caller?: string | null,
      tokenIn?: string | null,
      YT?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netPyOut?: null,
      netSyInterm?: null
    ): MintPyFromTokenEventFilter;

    "MintSyFromToken(address,address,address,address,uint256,uint256)"(
      caller?: string | null,
      tokenIn?: string | null,
      SY?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netSyOut?: null
    ): MintSyFromTokenEventFilter;
    MintSyFromToken(
      caller?: string | null,
      tokenIn?: string | null,
      SY?: string | null,
      receiver?: null,
      netTokenIn?: null,
      netSyOut?: null
    ): MintSyFromTokenEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "RedeemPyToSy(address,address,address,uint256,uint256)"(
      caller?: string | null,
      receiver?: string | null,
      YT?: string | null,
      netPyIn?: null,
      netSyOut?: null
    ): RedeemPyToSyEventFilter;
    RedeemPyToSy(
      caller?: string | null,
      receiver?: string | null,
      YT?: string | null,
      netPyIn?: null,
      netSyOut?: null
    ): RedeemPyToSyEventFilter;

    "RedeemPyToToken(address,address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      tokenOut?: string | null,
      YT?: string | null,
      receiver?: null,
      netPyIn?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RedeemPyToTokenEventFilter;
    RedeemPyToToken(
      caller?: string | null,
      tokenOut?: string | null,
      YT?: string | null,
      receiver?: null,
      netPyIn?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RedeemPyToTokenEventFilter;

    "RedeemSyToToken(address,address,address,address,uint256,uint256)"(
      caller?: string | null,
      tokenOut?: string | null,
      SY?: string | null,
      receiver?: null,
      netSyIn?: null,
      netTokenOut?: null
    ): RedeemSyToTokenEventFilter;
    RedeemSyToToken(
      caller?: string | null,
      tokenOut?: string | null,
      SY?: string | null,
      receiver?: null,
      netSyIn?: null,
      netTokenOut?: null
    ): RedeemSyToTokenEventFilter;

    "RemoveLiquidityDualSyAndPt(address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netPtOut?: null,
      netSyOut?: null
    ): RemoveLiquidityDualSyAndPtEventFilter;
    RemoveLiquidityDualSyAndPt(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netPtOut?: null,
      netSyOut?: null
    ): RemoveLiquidityDualSyAndPtEventFilter;

    "RemoveLiquidityDualTokenAndPt(address,address,address,address,uint256,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      tokenOut?: string | null,
      receiver?: null,
      netLpToRemove?: null,
      netPtOut?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RemoveLiquidityDualTokenAndPtEventFilter;
    RemoveLiquidityDualTokenAndPt(
      caller?: string | null,
      market?: string | null,
      tokenOut?: string | null,
      receiver?: null,
      netLpToRemove?: null,
      netPtOut?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RemoveLiquidityDualTokenAndPtEventFilter;

    "RemoveLiquiditySinglePt(address,address,address,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netPtOut?: null
    ): RemoveLiquiditySinglePtEventFilter;
    RemoveLiquiditySinglePt(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netPtOut?: null
    ): RemoveLiquiditySinglePtEventFilter;

    "RemoveLiquiditySingleSy(address,address,address,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netSyOut?: null
    ): RemoveLiquiditySingleSyEventFilter;
    RemoveLiquiditySingleSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netLpToRemove?: null,
      netSyOut?: null
    ): RemoveLiquiditySingleSyEventFilter;

    "RemoveLiquiditySingleToken(address,address,address,address,uint256,uint256,uint256)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpToRemove?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RemoveLiquiditySingleTokenEventFilter;
    RemoveLiquiditySingleToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netLpToRemove?: null,
      netTokenOut?: null,
      netSyInterm?: null
    ): RemoveLiquiditySingleTokenEventFilter;

    "SelectorToFacetSet(bytes4,address)"(
      selector?: BytesLike | null,
      facet?: string | null
    ): SelectorToFacetSetEventFilter;
    SelectorToFacetSet(
      selector?: BytesLike | null,
      facet?: string | null
    ): SelectorToFacetSetEventFilter;

    "SwapPtAndSy(address,address,address,int256,int256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netPtToAccount?: null,
      netSyToAccount?: null
    ): SwapPtAndSyEventFilter;
    SwapPtAndSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netPtToAccount?: null,
      netSyToAccount?: null
    ): SwapPtAndSyEventFilter;

    "SwapPtAndToken(address,address,address,address,int256,int256,uint256)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netPtToAccount?: null,
      netTokenToAccount?: null,
      netSyInterm?: null
    ): SwapPtAndTokenEventFilter;
    SwapPtAndToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netPtToAccount?: null,
      netTokenToAccount?: null,
      netSyInterm?: null
    ): SwapPtAndTokenEventFilter;

    "SwapYtAndSy(address,address,address,int256,int256)"(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netYtToAccount?: null,
      netSyToAccount?: null
    ): SwapYtAndSyEventFilter;
    SwapYtAndSy(
      caller?: string | null,
      market?: string | null,
      receiver?: string | null,
      netYtToAccount?: null,
      netSyToAccount?: null
    ): SwapYtAndSyEventFilter;

    "SwapYtAndToken(address,address,address,address,int256,int256,uint256)"(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netYtToAccount?: null,
      netTokenToAccount?: null,
      netSyInterm?: null
    ): SwapYtAndTokenEventFilter;
    SwapYtAndToken(
      caller?: string | null,
      market?: string | null,
      token?: string | null,
      receiver?: null,
      netYtToAccount?: null,
      netTokenToAccount?: null,
      netSyInterm?: null
    ): SwapYtAndTokenEventFilter;
  };

  estimateGas: {
    addLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netSyDesired: BigNumberish,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      input: TokenInputStruct,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySinglePt(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtSwapToSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleSy(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleSyKeepYt(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleSySimple(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleToken(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleTokenKeepYt(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquiditySingleTokenSimple(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    boostMarkets(
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    callAndReflect(
      reflector: string,
      selfCall1: BytesLike,
      selfCall2: BytesLike,
      reflectCall: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    exitPostExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    exitPostExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    exitPreExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    exitPreExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    limitRouterCallback(
      actualMaking: BigNumberish,
      actualTaking: BigNumberish,
      totalFee: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    mintPyFromSy(
      receiver: string,
      YT: string,
      netSyIn: BigNumberish,
      minPyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    mintPyFromToken(
      receiver: string,
      YT: string,
      minPyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    mintSyFromToken(
      receiver: string,
      SY: string,
      minSyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    multicall(
      calls: IPActionMiscV3.Call3Struct[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    redeemDueInterestAndRewards(
      user: string,
      sys: string[],
      yts: string[],
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemDueInterestAndRewardsV2(
      SYs: string[],
      YTs: RedeemYtIncomeToTokenStructStruct[],
      markets: string[],
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemPyToSy(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemPyToToken(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemSyToToken(
      receiver: string,
      SY: string,
      netSyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquiditySinglePt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquiditySingleSy(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquiditySingleToken(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    selectorToFacet(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setSelectorToFacets(
      arr: IPActionStorageV4.SelectorsToFacetStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    simulate(
      target: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapCallback(
      ptToAccount: BigNumberish,
      syToAccount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactPtForSy(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactPtForToken(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactSyForPt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactSyForPtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactSyForYt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactSyForYtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactTokenForPt(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactTokenForPtSimple(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactTokenForYt(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactTokenForYtSimple(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactYtForSy(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactYtForToken(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapTokenToTokenViaSy(
      receiver: string,
      SY: string,
      input: TokenInputStruct,
      tokenRedeemSy: string,
      minTokenOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapTokensToTokens(
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      netSwaps: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netSyDesired: BigNumberish,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      input: TokenInputStruct,
      netPtDesired: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySinglePt(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtSwapToSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleSy(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleSyKeepYt(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleSySimple(
      receiver: string,
      market: string,
      netSyIn: BigNumberish,
      minLpOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleToken(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleTokenKeepYt(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquiditySingleTokenSimple(
      receiver: string,
      market: string,
      minLpOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    boostMarkets(
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    callAndReflect(
      reflector: string,
      selfCall1: BytesLike,
      selfCall2: BytesLike,
      reflectCall: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    exitPostExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    exitPostExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    exitPreExpToSy(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    exitPreExpToToken(
      receiver: string,
      market: string,
      netPtIn: BigNumberish,
      netYtIn: BigNumberish,
      netLpIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    limitRouterCallback(
      actualMaking: BigNumberish,
      actualTaking: BigNumberish,
      totalFee: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    mintPyFromSy(
      receiver: string,
      YT: string,
      netSyIn: BigNumberish,
      minPyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    mintPyFromToken(
      receiver: string,
      YT: string,
      minPyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    mintSyFromToken(
      receiver: string,
      SY: string,
      minSyOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    multicall(
      calls: IPActionMiscV3.Call3Struct[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemDueInterestAndRewards(
      user: string,
      sys: string[],
      yts: string[],
      markets: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemDueInterestAndRewardsV2(
      SYs: string[],
      YTs: RedeemYtIncomeToTokenStructStruct[],
      markets: string[],
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemPyToSy(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      minSyOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemPyToToken(
      receiver: string,
      YT: string,
      netPyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemSyToToken(
      receiver: string,
      SY: string,
      netSyIn: BigNumberish,
      output: TokenOutputStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquidityDualSyAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquidityDualTokenAndPt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquiditySinglePt(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      guessPtReceivedFromSy: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquiditySinglePtSimple(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquiditySingleSy(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquiditySingleToken(
      receiver: string,
      market: string,
      netLpToRemove: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    selectorToFacet(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setSelectorToFacets(
      arr: IPActionStorageV4.SelectorsToFacetStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    simulate(
      target: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapCallback(
      ptToAccount: BigNumberish,
      syToAccount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactPtForSy(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactPtForToken(
      receiver: string,
      market: string,
      exactPtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactSyForPt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactSyForPtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minPtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactSyForYt(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactSyForYtSimple(
      receiver: string,
      market: string,
      exactSyIn: BigNumberish,
      minYtOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactTokenForPt(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      guessPtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactTokenForPtSimple(
      receiver: string,
      market: string,
      minPtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactTokenForYt(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      guessYtOut: ApproxParamsStruct,
      input: TokenInputStruct,
      limit: LimitOrderDataStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactTokenForYtSimple(
      receiver: string,
      market: string,
      minYtOut: BigNumberish,
      input: TokenInputStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactYtForSy(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      minSyOut: BigNumberish,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactYtForToken(
      receiver: string,
      market: string,
      exactYtIn: BigNumberish,
      output: TokenOutputStruct,
      limit: LimitOrderDataStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapTokenToTokenViaSy(
      receiver: string,
      SY: string,
      input: TokenInputStruct,
      tokenRedeemSy: string,
      minTokenOut: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapTokensToTokens(
      pendleSwap: string,
      swaps: SwapDataExtraStruct[],
      netSwaps: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
